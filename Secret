Secret

• ConfigMap: 컨테이너구성정보를한곳에모아서관리
• Secret : 컨테이너가사용하는password, auth token, sshkey와같은중요한정보를저장하고민감한구성정보를 base64로 인코딩해서한곳에모아서관리
• 민감하지않은일반설정파일configMap을사용하고민감한데이터는secret을사용
$ kubectlcreate secret genericeshop-secret \
--from-literal=PASSWORD=fastcam\
--from-literal=SCORE=90
-> 동작되는 컨테이너에게 전달해 주기위해 주로 사용
-> base64로 인코딩 되긴 했지만 보안적으로 유리한게 아니고 단순히 인코딩된 정보기 때문에 디코딩 하면 정보가 다시 노출됨

[user@console ~]$ kubectl create secret generic eshop --from-literal=DBNAME=mysql --from-literal=USER=admin
secret/eshop created
[user@console ~]$ kubectl get secrets
NAME                  TYPE                                  DATA   AGE
default-token-gvdn7   kubernetes.io/service-account-token   3      239d
eshop                 Opaque                                2      15s
[user@console ~]$ kubectl describe secrets eshop
Name:         eshop
Namespace:    default
Labels:       <none>
Annotations:  <none>

Type:  Opaque

Data
====
DBNAME:  5 bytes
USER:    5 bytes
[user@console ~]$ kubectl get secrets eshop -o yaml
apiVersion: v1
data:
  DBNAME: bXlzcWw=
  USER: YWRtaW4=
kind: Secret
metadata:
  creationTimestamp: "2022-09-20T08:29:15Z"
  name: eshop
  namespace: default
  resourceVersion: "754403"
  uid: d330d241-8d64-4917-a6c5-f273ee3be7a8
type: Opaque


◾ 작업클러스터: k8s
Name: super-secret
password: bob
Create a pod named pod-secrets-via-file, using the redisImage, which mounts a secret named super-secret at/secrets.
Create a second pod named pod-secrets-via-env, using the redisImage, which exports password as CONFIDENTIAL

kubectl create secret generic super-secret --from-literal=Password=bob
kubectl get secret
kubectl describe secrets super-secret

kubectl run pod-secrets-via-file --image=redis --dry-run=client -o yaml > pod-secrets-via-file.yaml

-> run은 한개의 pod 생성 명령어
